<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JS this | Lee Blog</title><meta name="author" content="李鹏辉,ahuinet@163.com"><meta name="copyright" content="李鹏辉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="有关于this ，我们说得最多的一句话就是谁调用，指向谁；也就是  this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象    其实， 在我们 JS 里边，要想真的理解 this..."><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://leejs.cn/3915840815/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JS this',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> Media</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://images-origin.wallwiz.link/59c12ed68ac7580001ce9ef8_1);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Lee Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">JS this</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> Media</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JS this</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-01T13:18:26.000Z" title="发表于 2020-03-01 21:18:26">2020-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-09T12:25:34.459Z" title="更新于 2025-01-09 20:25:34">2025-01-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>有关于<code>this</code> ，我们说得最多的一句话就是<strong>谁调用，指向谁</strong>；也就是</p>
<blockquote>
<p>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象</p>
</blockquote>
<span id="more"></span>

<p>其实， 在我们 JS 里边，要想真的理解 <code>this</code> ，只知道上边这一句话是完全不行的，我们可以从以下几个方面学习跟理解 <code>this</code> ：</p>
<p>从 <code>this</code> 绑定层面去理解：默认绑定，隐式绑定，显式绑定，<code>new</code> 绑定</p>
<p>从函数的运行环境层面去理解: <code>this</code>， 内存， 函数，环境变量</p>
<p>能过实际代码的上下文去理解</p>
<h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>先看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;global&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;foo&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();  <span class="comment">// global</span></span><br></pre></td></tr></table></figure>

<p>很显然， <code>foo</code> 函数执行的时候，所在的环境是 <code>window</code>, 所以 <code>this.name</code> 就是 <code>window</code> 的 <code>name</code> 属性</p>
<p>再看一个稍微复杂点的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// global</span></span><br><span class="line">  foo.<span class="property">name</span> = <span class="string">&quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">sayname</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// global</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayname</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>上边第一个 <code>this</code> 很好理解，是 <code>foo</code> 在全局环境下被调用，所以是 <code>global</code></p>
<p>而第二个 <code>this</code>，表面上看上去是在 <code>foo</code> 函数内部被执行，而且 <code>foo.name</code> 赋了新值 <code>&#39;foo&#39;</code>, 所以很容易就会认为第二个 <code>this</code> 会打印 <code>foo</code>， 其实不然；</p>
<p><code>sayname</code> 虽是在 <code>foo</code> 函数里边被执行，但并非是被 <code>foo</code> 函数调用，所以，调用 <code>sayname</code> 的还是 <code>window</code>; </p>
<p>可以参考下边代码进行理解:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// global</span></span><br><span class="line">  foo.<span class="property">name</span> = <span class="string">&quot;foo&quot;</span></span><br><span class="line">  foo.<span class="property">sayname</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// foo</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo.<span class="title function_">sayname</span>(); <span class="comment">// 这里的 sayname 函数才是被 foo 调用的，所以才会打印 foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>这就是默认绑定规则,它是 javascript 中最常见的一种函数调用模式，this 的绑定规则也是四种绑定规则中最简单的一种，就是绑定在全局作用域上。</p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>先看例子： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayname</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ahui = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ahui&quot;</span>,</span><br><span class="line">  <span class="attr">sayname</span>: sayname,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> angeli = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;angeli&quot;</span>,</span><br><span class="line">  <span class="attr">sayname</span>: sayname,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ahui.<span class="title function_">sayname</span>(); <span class="comment">// ahui</span></span><br><span class="line">angeli.<span class="title function_">sayname</span>(); <span class="comment">// angeli</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是隐式绑定，不难理解; 回到我们文章的第一句话，<strong>谁调用，指向谁</strong>，这里就分别是 <code>ahui</code> <code>angeli</code> 调用了 <code>sayname</code></p>
<p>专业一点的说法就是上下文对象，当给函数指定了这个上下文对象时，函数内部的 <code>this</code> 自然指向了这个上下文对象</p>
<p>在上边例子的基础上，我们再看一个稍微复杂点的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayname</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ahui = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ahui&quot;</span>,</span><br><span class="line">  <span class="attr">sayname</span>: sayname,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ahui.<span class="title function_">sayname</span>(); <span class="comment">// ahui</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ahuisayname = ahui.<span class="property">sayname</span>;</span><br><span class="line"><span class="title function_">ahuisayname</span>(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>

<p>这里的 ahui.sayname() 很好理解，肯定会打印 ahui ， 但是，当我们把 ahui.sayname 赋给一个新的变量之后， 为啥就变了呢 ？</p>
<p>这就是常见的<strong>隐式绑定时丢失上下文</strong></p>
<p>让我们来分析一下上边这个赋值语句：<strong>由于在 javascript 中，函数是对象，对象之间是引用传递，而不是值传递。</strong>  所以这个赋值语句可以理解为 <code>ahuisayname = ahui.sayname = sayname</code>, 也就是 <code>ahuisayname = sayname</code> ,  <code>ahui.sayname</code> 只起了一个桥梁的作用, <code>ahuisayname</code> 最终引用的就是 <code>sayname</code> 函数的地址，而与 <code>ahui</code> 这个对象没有关系了。最终执行 <code>ahuisayname</code> 这个函数，中不过是简单的执行 <code>sayname</code> 这个函数，输出 <code>&#39;global&#39;</code>。</p>
<p>这里的详细分析，可以看一下这篇文章： <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html">JavaScript 的 this 原理</a></p>
<h3 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h3><p>js中提示显示绑定的方法有3个 <code>call</code> <code>apply</code> <code>bind</code></p>
<p><code>call</code> <code>apply</code> 用法基本相似，就是给函数绑定一个执行上下文，且是显式绑定的。因此，函数内的this自然而然的绑定在了 <code>call</code> 或者 <code>apply</code> 所调用的对象上面。</p>
<blockquote>
<p><code>apply(obj,[arg1,arg2,arg3,...]</code> 被调用函数的参数以数组的形式给出<br><code>call(obj,arg1,arg2,arg3,...)</code> 被调用函数的参数依次给出</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span> * num1 + num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count.<span class="title function_">call</span>(obj1, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line">count.<span class="title function_">apply</span>(obj1, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">count.<span class="title function_">call</span>(obj2, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 5</span></span><br><span class="line">count.<span class="title function_">apply</span>(obj2, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p><code>bind</code> 方法只是返回了一个新的函数，这个函数内的 <code>this</code> 指定了执行上下文，而返回这个新函数可以接受参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span> * num1 + num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bound1 = count.<span class="title function_">bind</span>(obj1) <span class="comment">// 未指定参数</span></span><br><span class="line"><span class="title function_">bound1</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bound2 = count.<span class="title function_">bind</span>(obj1, <span class="number">1</span>) <span class="comment">// 指定了一个参数</span></span><br><span class="line"><span class="title function_">bound2</span>(<span class="number">2</span>) <span class="comment">// 4 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bound3 = count.<span class="title function_">bind</span>(obj1, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 指定了两个参数</span></span><br><span class="line"><span class="title function_">bound3</span>() <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bound4 = count.<span class="title function_">bind</span>(obj1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 指定了多余的参数,多余的参数会被忽略</span></span><br><span class="line"><span class="title function_">bound4</span>() <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><p>最后要讲的一种 <code>this</code> 绑定规则，是指通过 <code>new</code> 操作符调用构造函数时发生的 <code>this</code> 绑定。首先要明确一点的是，在 javascript 中并没有其他语言那样的类的概念。构造函数也仅仅是普通的函数而已，只不过构造函数的函数名以大写字母开头，也只不过它可以通过 <code>new</code> 操作符调用而已.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我也只不过是个普通函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&quot;ahui&quot;</span>,<span class="number">18</span>) <span class="comment">// &quot;我也只不过是个普通函数&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// &quot;ahui&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zxt = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;angeli&quot;</span>,<span class="number">22</span>) <span class="comment">// &quot;我也只不过是个普通函数&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zxt.<span class="property">name</span>) <span class="comment">// &quot;angeli&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zxt.<span class="property">age</span>) <span class="comment">// 22</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子中，首先定义了一个 <code>Person</code> 函数，既可以普通调用，也可以以构造函数的形式的调用。</p>
<p>当普通调用时，则按照正常的函数执行，输出一个字符串。 </p>
<p>如果是通过一个 <code>new</code> 操作符,则构造了一个新的对象。</p>
<p>那么，接下来我们再看看两种调用方式， <code>this</code> 分别绑定在了何处首先普通调用时，前面已经介绍过，此时应用默认绑定规则，<code>this</code> 绑定在了全局对象上，此时全局对象上会分别增加 name 和 age 两个属性。当通过 <code>new</code> 操作符调用时，函数会返回一个对象，从输出结果上来看 <code>this</code> 对象绑定在了这个返回的对象上。</p>
<p>因此，所谓的 <code>new</code> 绑定是指通过 <code>new</code> 操作符来调用函数时，会产生一个新对象，并且会把构造函数内的 <code>this</code> 绑定到这个对象上。</p>
<p>事实上，在javascript中，使用 <code>new</code> 来调用函数，会自动执行下面的操作。详情可看这里： <a href="/3315289936.html">new 一个对象的过程</a></p>
<blockquote>
<ol>
<li>创建一个全新的对象</li>
<li>这个新对象会被执行原型连接</li>
<li>这个新对象会绑定到函数调用的this</li>
<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象</li>
</ol>
</blockquote>
<h3 id="四种绑定的优先级"><a href="#四种绑定的优先级" class="headerlink" title="四种绑定的优先级"></a>四种绑定的优先级</h3><p>上面讲述了javascript中四种this绑定规则，这四种绑定规则基本上涵盖了所有函数调用情况。但是如果同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四种绑定的优先级顺序又是怎么样的。</p>
<p>首先，很容易理解，默认绑定的优先级是最低的。这是因为只有在无法应用其他this绑定规则的情况下，才会调用默认绑定。那隐式绑定和显式绑定呢？还是上代码吧，代码可从来不会说谎。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj1&#x27;</span>,</span><br><span class="line">    <span class="attr">speak</span>: speak</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">speak</span>() <span class="comment">// obj1 (1)</span></span><br><span class="line">obj1.<span class="property">speak</span>.<span class="title function_">call</span>(obj2) <span class="comment">// obj2 (2)</span></span><br></pre></td></tr></table></figure>
<p>所以在上面代码中，执行了obj1.speak(),speak函数内部的this指向了obj1，因此(1)处代码输出的当然就是obj1，但是当显式绑定了speak函数内的this到obj2上，输出结果就变成了obj2，所有从这个结果可以看出显式绑定的优先级是要高于隐式绑定的。</p>
<p>事实上我们可以这么理解obj1.speak.call(obj2)这行代码，obj1.speak只是间接获得了speak函数的引用，这就有点像前面所说的隐式绑定丢失了上下文。</p>
<p>好，既然显式绑定的优先级要高于隐式绑定，那么接下来再来比较一下new 绑定和显式绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj1)  <span class="comment">// 返回一个新函数bar，这个新函数内的this指向了obj1  (1)</span></span><br><span class="line"><span class="title function_">bar</span>(<span class="number">2</span>) <span class="comment">// this绑定在了Obj1上，所以obj1.a === 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>(<span class="number">3</span>)  <span class="comment">// 调用new 操作符后，bar函数的this指向了返回的新实例baz  (2)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">a</span>) </span><br></pre></td></tr></table></figure>

<p>我们可以看到，在(1)处，bar函数内部的this原本指向的是obj1，但是在(2)处，由于经过了new操作符调用，bar函数内部的this却重新指向了返回的实例，这就可以说明new 绑定的优先级是要高于显式绑定的。</p>
<p>至此，四种绑定规则的优先级排序就已经得出了,分别是</p>
<blockquote>
<p>new 绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
</blockquote>
<h3 id="箭头函数中的this绑定"><a href="#箭头函数中的this绑定" class="headerlink" title="箭头函数中的this绑定"></a>箭头函数中的this绑定</h3><p>箭头函数是ES6里一个重要的特性。</p>
<p>箭头函数的 <code>this</code> 是根据外层的（函数或者全局）作用域来决定的。函数体内的 <code>this</code> 对象指的是定义时所在的对象，而不是之前介绍的调用时绑定的对象。举一个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>) <span class="comment">// 定义在全局对象中，因此this绑定在全局作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 1 ,在全局对象中调用</span></span><br><span class="line">foo.<span class="title function_">call</span>(obj) <span class="comment">// 1,显示绑定，由obj对象来调用，但根本不影响结果</span></span><br></pre></td></tr></table></figure>

<p>从上面这个例子看出，箭头函数的 <code>this</code> 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如 <code>apply,call</code> 方法来修改。</p>
<p>再来看下面这个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speak</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">        <span class="comment">// 普通函数（非箭头函数),this绑定在调用时的作用域</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bornYear</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 本文写于2020年，因此new Date().getFullYear()得到的是2020</span></span><br><span class="line">        <span class="comment">// 箭头函数，this绑定在实例内部</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ahui = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;ahui&quot;</span>,<span class="number">28</span>)</span><br><span class="line"></span><br><span class="line">ahui.<span class="title function_">speak</span>() <span class="comment">// &quot;ahui&quot;</span></span><br><span class="line">ahui.<span class="title function_">bornYear</span>() <span class="comment">// 1992</span></span><br><span class="line"><span class="comment">// 到这里应该大家应该都没什么问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> angeli = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;angeli&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>  <span class="comment">// 永远18岁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ahui.<span class="property">speak</span>.<span class="title function_">call</span>(angeli)</span><br><span class="line"><span class="comment">// &quot;angeli&quot; this绑定的是angeli这个对象</span></span><br><span class="line"></span><br><span class="line">ahui.<span class="property">bornYear</span>.<span class="title function_">call</span>(angeli)</span><br><span class="line"><span class="comment">// 1992 而不是 2002,这是因为this永远绑定的是ahui这个实例</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此 ES6 的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 <code>this</code> ，具体来说就是，箭头函数会继承 外层函数调用的 <code>this</code> 绑定 ，而无论外层函数的 <code>this</code> 绑定到哪里。</p>
<p>小结<br>以上就是javascript中所有this绑定的情况，在es6之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6标准实施以后，对于函数的扩展新增了箭头函数，与之前不同的是，箭头函数的作用域位于箭头函数定义时所在的作用域。</p>
<p>而对于之前的四种绑定规则来说，掌握每种规则的调用条件就能很好的理解this到底是绑定在了哪个作用域。</p>
<p>原文地址： <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007101339">JavaScript中this绑定详解</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://leejs.cn">李鹏辉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://leejs.cn/3915840815/">https://leejs.cn/3915840815/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://leejs.cn" target="_blank">Lee Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/js/">js</a><a class="post-meta__tags" href="/tags/web/">web</a><a class="post-meta__tags" href="/tags/this/">this</a></div><div class="post-share"><div class="social-share" data-image="https://images-origin.wallwiz.link/59c12ed68ac7580001ce9ef8_1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/3152193188/" title="浏览器 地址栏回车 性能优化"><img class="cover" src="https://images-origin.wallwiz.link/58860ea5bcf65400017a54f0_1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">浏览器 地址栏回车 性能优化</div></div><div class="info-2"><div class="info-item-1">Enter1. 输入地址比如： didiorg.com&#x2F;   2. DNS（Domain Name System，）解析：浏览器查找域名的 IP 地址本地 hosts 文件 &#x3D;&gt; 本地 DNS 服务器 &#x3D;&gt; DNS 根服务器本地 DNS 服务器 &#x3D;&gt; com 域服务器本地 DNS 服务器 &#x3D;&gt; 域名解析服务器 　这个过程很有意思，本地 DNS 服务器访问根服务器，当根胳没有的时候，并不是根服务器去访问 com 域服务器，这个时候，DNS 根服务器只会告诉 本地 DNS 服务器他没有， 叫他再去访问 com 域服务器。 　更有意思的是， 当本地 DNS 服务器访问 com 域服务器的时候，com 域服务器也不会直接给 本地 DNS 服务器 一个 IP 地址， 而是告诉本地 DNS 服务器想要查找的那个域名的域名解析服务器的地址 然后， 本地 DNS 服务器通过刚才拿到的址， 再去访问域名解析服务器，从那里拿到 IP 地址。 3. 浏览器向服务器发 http 请求拿到 ip 后，浏览器会向服务器80端口发起...</div></div></div></a><a class="pagination-related" href="/3369490582/" title="JS typeof instanceof 你应该知道这么多"><img class="cover" src="https://images-origin.wallwiz.link/58860ba7dc1d3f00010acdef_1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JS typeof instanceof 你应该知道这么多</div></div><div class="info-2"><div class="info-item-1">typeof主要是用来判断一个变量的类型  几个特殊的情况记一下： 123456typeof null // objecttypeof &#123;&#125; // objecttypeof [] // objecttypeof Object // functiontypeof Function // functiontypeof undefined // undefined 看到上边  typeof Object 的结果是 function 这里其实因为 Object 是一个构造函数， 而不是一个真正的对象， 只有实例化之后才会给出 object的结果 可以看一下下边代码： 1234console.log(typeof Object); // functionlet ahui = new Object();console.log(typeof ahui); // object  再看到上边： typeof null typeof &#123;&#125; typeof [] 结果都是 object， 很显然， 我们是不能通过 typeof...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/3315289936/" title="JS new 一个对象的过程"><img class="cover" src="https://images-origin.wallwiz.link/5976161269f78700012df74f_1" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-29</div><div class="info-item-2">JS new 一个对象的过程</div></div><div class="info-2"><div class="info-item-1">首先让我回忆一下创建对象的三种方法    单休模式  1234567891011const Person  = &#123;  name: &quot;angelee&quot;,  sayname: function() &#123;    return this.name;  &#125;&#125;let ahui = Object.create(Person);ahui.name = &quot;ahui&quot;console.log(ahui.sayname()) // ahui   构造函数  123456789const Person = function (name) &#123;  this.name = name;&#125;Person.prototype.sayname = function () &#123;  return this.name;&#125;let ahui = new Person(&quot;ahui&quot;);console.log(ahui.sayname()); // ahui   ES6...</div></div></div></a><a class="pagination-related" href="/880232555/" title="JS dom元素位置相关的内容"><img class="cover" src="https://images-origin.wallwiz.link/58860c5cdc1d3f00010acee5_1" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-27</div><div class="info-item-2">JS dom元素位置相关的内容</div></div><div class="info-2"><div class="info-item-1">offsetWidth: 返回元素的宽度（包括元素宽度 + 内边距 + 边框，不包括外边距）   offsetHeight: 返回元素的高度（包括元素高度 + 内边距 + 边框，不包括外边距） clientWidth: 返回元素的宽度（包括元素宽度 + 内边距，不包括边框和外边距） clientHeight: 返回元素的高度（包括元素高度 + 内边距，不包括边框和外边距） style.width: 返回元素的宽度（包括元素宽度，不包括内边距、边框和外边距） style.height: 返回元素的高度（包括元素高度，不包括内边距、边框和外边距） scrollWidth: 返回元素的宽度（包括元素宽度 + 内边距 + 溢出尺寸，不包括边框和外边距），无溢出的情况，与clientWidth相同 scrollHeigh: 返回元素的高度（包括元素高度 + 内边距 + 溢出尺寸，不包括边框和外边距），无溢出的情况，与clientHeight相同   style.width...</div></div></div></a><a class="pagination-related" href="/proto/" title="JS __proto__和prototype的区别和关系"><img class="cover" src="https://images-origin.wallwiz.link/58860f916e9f6a00013b94fb_1" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="info-item-2">JS __proto__和prototype的区别和关系</div></div><div class="info-2"><div class="info-item-1">首先，看别人怎么说的：1.在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)也是对象。它们都会具有对象共有的特点:对象具有属性 __proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。   2.方法(Function)方法这个特殊的对象，除了和其他对象一样有上述 __proto__...</div></div></div></a><a class="pagination-related" href="/prototype/" title="JS prototype"><img class="cover" src="https://images-origin.wallwiz.link/58860f026e9f6a00013b9428_1" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-29</div><div class="info-item-2">JS prototype</div></div><div class="info-2"><div class="info-item-1">在典型的面向对象的语言中，如java，都存在类（class）的概念，类就是对象的模板，对象就是类的实例。但是在Javascript语言体系中，是不存在类（Class）的概念的，javascript中不是基于‘类的’，而是通过构造函数（constructor）和原型链（prototype...</div></div></div></a><a class="pagination-related" href="/isArray/" title="JS判断一个变量是否是数组"><img class="cover" src="https://images-origin.wallwiz.link/59c13323c6a7580001cc9bfd_1" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-30</div><div class="info-item-2">JS判断一个变量是否是数组</div></div><div class="info-2"><div class="info-item-1">1. isArray()isArray 是 Array 的一个方法， 如果是数组返回 true, 否则返回 false   123var a = [1, 2, 3];console.log(typeof a); //返回“object”console.log(Array.isArray(a)); //true  2. instanceofinstanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 123object instanceof constructorobject // 实例constructor // 构造函数 用来检测 constructor.prototype 是否存在于参数 object 的原型链上 (object.__proto__/object.__proto__.__proto__.......__proto__) 1234567var arr = new Array();var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var obj =...</div></div></div></a><a class="pagination-related" href="/3369490582/" title="JS typeof instanceof 你应该知道这么多"><img class="cover" src="https://images-origin.wallwiz.link/58860ba7dc1d3f00010acdef_1" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-01</div><div class="info-item-2">JS typeof instanceof 你应该知道这么多</div></div><div class="info-2"><div class="info-item-1">typeof主要是用来判断一个变量的类型  几个特殊的情况记一下： 123456typeof null // objecttypeof &#123;&#125; // objecttypeof [] // objecttypeof Object // functiontypeof Function // functiontypeof undefined // undefined 看到上边  typeof Object 的结果是 function 这里其实因为 Object 是一个构造函数， 而不是一个真正的对象， 只有实例化之后才会给出 object的结果 可以看一下下边代码： 1234console.log(typeof Object); // functionlet ahui = new Object();console.log(typeof ahui); // object  再看到上边： typeof null typeof &#123;&#125; typeof [] 结果都是 object， 很显然， 我们是不能通过 typeof...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">李鹏辉</div><div class="author-info-description">学习 生活 成长</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A"><span class="toc-number">1.</span> <span class="toc-text">默认绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-number">2.</span> <span class="toc-text">隐式绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%BB%91%E5%AE%9A"><span class="toc-number">3.</span> <span class="toc-text">显示绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E7%BB%91%E5%AE%9A"><span class="toc-number">4.</span> <span class="toc-text">new 绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">5.</span> <span class="toc-text">四种绑定的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this%E7%BB%91%E5%AE%9A"><span class="toc-number">6.</span> <span class="toc-text">箭头函数中的this绑定</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/873586f3/" title="readme"><img src="https://images-origin.wallwiz.link/58860e96dc1d3f00010ad1e2_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="readme"/></a><div class="content"><a class="title" href="/873586f3/" title="readme">readme</a><time datetime="2025-01-09T12:29:34.000Z" title="发表于 2025-01-09 20:29:34">2025-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0/" title="无标题"><img src="https://images-origin.wallwiz.link/5891eb8635e2fb00012d3a4f_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/0/" title="无标题">无标题</a><time datetime="2025-01-09T12:25:34.447Z" title="发表于 2025-01-09 20:25:34">2025-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/a70288e8/" title="Docker常见命令"><img src="https://images-origin.wallwiz.link/59c12ed68ac7580001ce9ef8_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker常见命令"/></a><div class="content"><a class="title" href="/a70288e8/" title="Docker常见命令">Docker常见命令</a><time datetime="2024-09-06T02:36:57.000Z" title="发表于 2024-09-06 10:36:57">2024-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/undefined/" title="class-transformer"><img src="https://images-origin.wallwiz.link/58860b66bcf65400017a5089_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="class-transformer"/></a><div class="content"><a class="title" href="/undefined/" title="class-transformer">class-transformer</a><time datetime="2024-04-08T03:27:34.000Z" title="发表于 2024-04-08 11:27:34">2024-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5feabfc2/" title="浏览器indexDB"><img src="https://images-origin.wallwiz.link/588609686e9f6a00013b8c2f_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浏览器indexDB"/></a><div class="content"><a class="title" href="/5feabfc2/" title="浏览器indexDB">浏览器indexDB</a><time datetime="2024-03-07T11:59:05.000Z" title="发表于 2024-03-07 19:59:05">2024-03-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 李鹏辉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>